<!doctype html>
<html lang="en-us">
  <head>
    <title>JAVA核心技术 第四章 类与对象 第二部分 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.62.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="不停" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://rosealice2018.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JAVA核心技术 第四章 类与对象 第二部分"/>
<meta name="twitter:description" content="4.4.4 工厂方法 1.静态方法
 无法命名构造器。 当使用构造器时，无法改变所构造的对象类型。  4.5 方法参数 1.方法参数的类型
 基本数据类型（数字，布尔值） 对象引用  2.重点：在JAVA语言中，对于方法参数中的对象引用，实际上是将对象引用进行拷贝，然后再拷贝的基础上进行操作。 eg:
public static void swap(Employee x,Employee y) { Employee temp=x; x=y; y=x; }  这里并不能实现x与y的交换，因为x和y是拷贝的引用副本，在方法执行完毕后就会消失。 实际上，对象引用是按值传递的。  4.6 对象构造 4.6.1 重载  多个方法，有相同的名字，不同的参数，便产生了重载。 返回类型并非方法签名的一部分，同名且同参数的方法，不能因为返回值不同而认为重载。  4.6.2 无参数的构造器  仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。如果在编写类的时候，给出了构造器，则（如果需要默认构造器）必须自己实现。  4.6.2 显示域初始化  在调用构造器之前，先进行赋值操作。（当一个类的所有构造器都希望将相同的值赋值给某个特定实例域时，十分有用）。  public static class Employee{ private static int nextId; private int id=assignId(); private static int assignId() { int r=nextId; nextId&#43;&#43;; return r; } } 在C&#43;&#43;中，不能直接初始化类的实例域。所有的域必须在构造器中设置。但是有一个特殊的初始化列表语法，如下所示"/>

    <meta property="og:title" content="JAVA核心技术 第四章 类与对象 第二部分" />
<meta property="og:description" content="4.4.4 工厂方法 1.静态方法
 无法命名构造器。 当使用构造器时，无法改变所构造的对象类型。  4.5 方法参数 1.方法参数的类型
 基本数据类型（数字，布尔值） 对象引用  2.重点：在JAVA语言中，对于方法参数中的对象引用，实际上是将对象引用进行拷贝，然后再拷贝的基础上进行操作。 eg:
public static void swap(Employee x,Employee y) { Employee temp=x; x=y; y=x; }  这里并不能实现x与y的交换，因为x和y是拷贝的引用副本，在方法执行完毕后就会消失。 实际上，对象引用是按值传递的。  4.6 对象构造 4.6.1 重载  多个方法，有相同的名字，不同的参数，便产生了重载。 返回类型并非方法签名的一部分，同名且同参数的方法，不能因为返回值不同而认为重载。  4.6.2 无参数的构造器  仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。如果在编写类的时候，给出了构造器，则（如果需要默认构造器）必须自己实现。  4.6.2 显示域初始化  在调用构造器之前，先进行赋值操作。（当一个类的所有构造器都希望将相同的值赋值给某个特定实例域时，十分有用）。  public static class Employee{ private static int nextId; private int id=assignId(); private static int assignId() { int r=nextId; nextId&#43;&#43;; return r; } } 在C&#43;&#43;中，不能直接初始化类的实例域。所有的域必须在构造器中设置。但是有一个特殊的初始化列表语法，如下所示" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rosealice2018.github.io/post/first/" />
<meta property="article:published_time" content="2020-07-16T13:28:35+08:00" />
<meta property="article:modified_time" content="2020-07-16T13:28:35+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://rosealice2018.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="不停" /></a>
      <h1></h1>
      <p>云空未必空</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/RoseAlice2018" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">JAVA核心技术 第四章 类与对象 第二部分</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 16, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h2 id="444-工厂方法">4.4.4 工厂方法</h2>
<p>1.静态方法</p>
<ul>
<li>无法命名构造器。</li>
<li>当使用构造器时，无法改变所构造的对象类型。</li>
</ul>
<h2 id="45-方法参数">4.5 方法参数</h2>
<p>1.方法参数的类型</p>
<ul>
<li>基本数据类型（数字，布尔值）</li>
<li>对象引用</li>
</ul>
<p>2.重点：在JAVA语言中，对于方法参数中的对象引用，实际上是将对象引用进行拷贝，然后再拷贝的基础上进行操作。
eg:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">public  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(Employee x,Employee y)
    {
        Employee temp<span style="color:#f92672">=</span>x;
        x<span style="color:#f92672">=</span>y;
        y<span style="color:#f92672">=</span>x;
    }
</code></pre></div><ul>
<li>这里并不能实现x与y的交换，因为x和y是拷贝的引用副本，在方法执行完毕后就会消失。</li>
<li>实际上，对象引用是按值传递的。</li>
</ul>
<h2 id="46-对象构造">4.6 对象构造</h2>
<h3 id="461-重载">4.6.1 重载</h3>
<ul>
<li>多个方法，有相同的名字，不同的参数，便产生了重载。</li>
<li>返回类型并非方法签名的一部分，同名且同参数的方法，不能因为返回值不同而认为重载。</li>
</ul>
<h3 id="462-无参数的构造器">4.6.2 无参数的构造器</h3>
<ul>
<li>仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。如果在编写类的时候，给出了构造器，则（如果需要默认构造器）必须自己实现。</li>
</ul>
<h3 id="462-显示域初始化">4.6.2 显示域初始化</h3>
<ul>
<li>在调用构造器之前，先进行赋值操作。（当一个类的所有构造器都希望将相同的值赋值给某个特定实例域时，十分有用）。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> public <span style="color:#66d9ef">static</span> class Employee{
        private <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> nextId;
        private <span style="color:#66d9ef">int</span> id<span style="color:#f92672">=</span>assignId();
        private <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">assignId</span>()
        {
            <span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span>nextId;
            nextId<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
            <span style="color:#66d9ef">return</span>  r;
        }
    }
</code></pre></div><p><strong>在C++中，不能直接初始化类的实例域。所有的域必须在构造器中设置。但是有一个特殊的初始化列表语法，如下所示</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
Employee<span style="color:#f92672">:</span><span style="color:#f92672">:</span>Employee(String n,<span style="color:#66d9ef">double</span> s,<span style="color:#66d9ef">int</span> y,<span style="color:#66d9ef">int</span> m,<span style="color:#66d9ef">int</span> d)
<span style="color:#f92672">:</span>name(n),salary(s),hireDay(y,m,d)
{
    
}
</code></pre></div><h3 id="466--调用另一个构造器">4.6.6  调用另一个构造器</h3>
<ul>
<li>如果构造器的第一个语句形如(this(&hellip;))，这个构造器将调用另一个同类的构造器。</li>
<li>采用这样的this关键字非常有用，这样对于公共的构造器代码部分只编写一次就行。</li>
</ul>
<h3 id="467-初始化块">4.6.7 初始化块</h3>
<ul>
<li>第三种初始化数据域的方法，不常用。</li>
</ul>
<h3 id="468-finalize对象析构">4.6.8 finalize（对象析构）</h3>
<ul>
<li>不常用</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
